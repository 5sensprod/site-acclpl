{"version":3,"sources":["node_modules/fetch-jsonp/build/fetch-jsonp.js","node_modules/bbox-intersect/index.js","node_modules/leaflet-bing-layer/index.js"],"names":[],"mappings":"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","file":"leaflet-bing-layer.c766ae0f.js","sourceRoot":"..","sourcesContent":["(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['exports', 'module'], factory);\n  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {\n    factory(exports, module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, mod);\n    global.fetchJsonp = mod.exports;\n  }\n})(this, function (exports, module) {\n  'use strict';\n\n  var defaultOptions = {\n    timeout: 5000,\n    jsonpCallback: 'callback',\n    jsonpCallbackFunction: null\n  };\n\n  function generateCallbackFunction() {\n    return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);\n  }\n\n  function clearFunction(functionName) {\n    // IE8 throws an exception when you try to delete a property on window\n    // http://stackoverflow.com/a/1824228/751089\n    try {\n      delete window[functionName];\n    } catch (e) {\n      window[functionName] = undefined;\n    }\n  }\n\n  function removeScript(scriptId) {\n    var script = document.getElementById(scriptId);\n    if (script) {\n      document.getElementsByTagName('head')[0].removeChild(script);\n    }\n  }\n\n  function fetchJsonp(_url) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    // to avoid param reassign\n    var url = _url;\n    var timeout = options.timeout || defaultOptions.timeout;\n    var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;\n\n    var timeoutId = undefined;\n\n    return new Promise(function (resolve, reject) {\n      var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();\n      var scriptId = jsonpCallback + '_' + callbackFunction;\n\n      window[callbackFunction] = function (response) {\n        resolve({\n          ok: true,\n          // keep consistent with fetch API\n          json: function json() {\n            return Promise.resolve(response);\n          }\n        });\n\n        if (timeoutId) clearTimeout(timeoutId);\n\n        removeScript(scriptId);\n\n        clearFunction(callbackFunction);\n      };\n\n      // Check if the user set their own params, and if not add a ? to start a list of params\n      url += url.indexOf('?') === -1 ? '?' : '&';\n\n      var jsonpScript = document.createElement('script');\n      jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);\n      if (options.charset) {\n        jsonpScript.setAttribute('charset', options.charset);\n      }\n      if (options.nonce) {\n        jsonpScript.setAttribute('nonce', options.nonce);\n      }\n      if (options.referrerPolicy) {\n        jsonpScript.setAttribute('referrerPolicy', options.referrerPolicy);\n      }\n      jsonpScript.id = scriptId;\n      document.getElementsByTagName('head')[0].appendChild(jsonpScript);\n\n      timeoutId = setTimeout(function () {\n        reject(new Error('JSONP request to ' + _url + ' timed out'));\n\n        clearFunction(callbackFunction);\n        removeScript(scriptId);\n        window[callbackFunction] = function () {\n          clearFunction(callbackFunction);\n        };\n      }, timeout);\n\n      // Caught if got 404/500\n      jsonpScript.onerror = function () {\n        reject(new Error('JSONP request to ' + _url + ' failed'));\n\n        clearFunction(callbackFunction);\n        removeScript(scriptId);\n        if (timeoutId) clearTimeout(timeoutId);\n      };\n    });\n  }\n\n  // export as global function\n  /*\n  let local;\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n  local.fetchJsonp = fetchJsonp;\n  */\n\n  module.exports = fetchJsonp;\n});","module.exports = function(bbox1, bbox2){\n  if(!(\n      bbox1[0] > bbox2[2] ||\n      bbox1[2] < bbox2[0] ||\n      bbox1[3] < bbox2[1] ||\n      bbox1[1] > bbox2[3]\n    )){\n      return true;\n  } else {\n    return false;\n  }\n}","var L = require('leaflet')\nvar fetchJsonp = require('fetch-jsonp')\nvar bboxIntersect = require('bbox-intersect')\n\n/**\n * Converts tile xyz coordinates to Quadkey\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @return {Number} Quadkey\n */\nfunction toQuadKey (x, y, z) {\n  var index = ''\n  for (var i = z; i > 0; i--) {\n    var b = 0\n    var mask = 1 << (i - 1)\n    if ((x & mask) !== 0) b++\n    if ((y & mask) !== 0) b += 2\n    index += b.toString()\n  }\n  return index\n}\n\n/**\n * Converts Leaflet BBoxString to Bing BBox\n * @param {String} bboxString 'southwest_lng,southwest_lat,northeast_lng,northeast_lat'\n * @return {Array} [south_lat, west_lng, north_lat, east_lng]\n */\nfunction toBingBBox (bboxString) {\n  var bbox = bboxString.split(',')\n  return [bbox[1], bbox[0], bbox[3], bbox[2]]\n}\n\nvar VALID_IMAGERY_SETS = [\n  'Aerial',\n  'AerialWithLabels',\n  'AerialWithLabelsOnDemand',\n  'Road',\n  'RoadOnDemand',\n  'CanvasLight',\n  'CanvasDark',\n  'CanvasGray',\n  'OrdnanceSurvey'\n]\n\nvar DYNAMIC_IMAGERY_SETS = [\n  'AerialWithLabelsOnDemand',\n  'RoadOnDemand'\n]\n\n/**\n * Create a new Bing Maps layer.\n * @param {string|object} options Either a [Bing Maps Key](https://msdn.microsoft.com/en-us/library/ff428642.aspx) or an options object\n * @param {string} options.BingMapsKey A valid Bing Maps Key (required)\n * @param {string} [options.imagerySet=Aerial] Type of imagery, see https://msdn.microsoft.com/en-us/library/ff701716.aspx\n * @param {string} [options.culture='en-US'] Language for labels, see https://msdn.microsoft.com/en-us/library/hh441729.aspx\n * @return {L.TileLayer} A Leaflet TileLayer to add to your map\n *\n * Create a basic map\n * @example\n * var map = L.map('map').setView([51.505, -0.09], 13)\n * L.TileLayer.Bing(MyBingMapsKey).addTo(map)\n */\nL.TileLayer.Bing = L.TileLayer.extend({\n  options: {\n    bingMapsKey: null, // Required\n    imagerySet: 'Aerial',\n    culture: 'en-US',\n    minZoom: 1,\n    minNativeZoom: 1,\n    maxNativeZoom: 19\n  },\n\n  statics: {\n    METADATA_URL: 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?key={bingMapsKey}&include=ImageryProviders&uriScheme=https&c={culture}',\n    POINT_METADATA_URL: 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}/{lat},{lng}?zl={z}&key={bingMapsKey}&uriScheme=https&c={culture}'\n  },\n\n  initialize: function (options) {\n    if (typeof options === 'string') {\n      options = { bingMapsKey: options }\n    }\n    if (options && options.BingMapsKey) {\n      options.bingMapsKey = options.BingMapsKey\n      console.warn('use options.bingMapsKey instead of options.BingMapsKey')\n    }\n    if (!options || !options.bingMapsKey) {\n      throw new Error('Must supply options.BingMapsKey')\n    }\n    options = L.setOptions(this, options)\n    if (VALID_IMAGERY_SETS.indexOf(options.imagerySet) < 0) {\n      throw new Error(\"'\" + options.imagerySet + \"' is an invalid imagerySet, see https://github.com/digidem/leaflet-bing-layer#parameters\")\n    }\n    if (options && options.style && DYNAMIC_IMAGERY_SETS.indexOf(options.imagerySet) < 0) {\n      console.warn('Dynamic styles will only work with these imagerySet choices: ' + DYNAMIC_IMAGERY_SETS.join(', '))\n    }\n\n    var metaDataUrl = L.Util.template(L.TileLayer.Bing.METADATA_URL, {\n      bingMapsKey: this.options.bingMapsKey,\n      imagerySet: this.options.imagerySet,\n      culture: this.options.culture\n    })\n\n    this._imageryProviders = []\n    this._attributions = []\n\n    // Keep a reference to the promise so we can use it later\n    this._fetch = fetchJsonp(metaDataUrl, {jsonpCallback: 'jsonp'})\n      .then(function (response) {\n        return response.json()\n      })\n      .then(this._metaDataOnLoad.bind(this))\n      .catch(console.error.bind(console))\n\n    // for https://github.com/Leaflet/Leaflet/issues/137\n    if (!L.Browser.android) {\n      this.on('tileunload', this._onTileRemove)\n    }\n  },\n\n  createTile: function (coords, done) {\n    var tile = document.createElement('img')\n\n    L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile))\n    L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile))\n\n    if (this.options.crossOrigin) {\n      tile.crossOrigin = ''\n    }\n\n    /*\n     Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\n     http://www.w3.org/TR/WCAG20-TECHS/H67\n    */\n    tile.alt = ''\n\n    // Don't create closure if we don't have to\n    if (this._url) {\n      tile.src = this.getTileUrl(coords)\n    } else {\n      this._fetch.then(function () {\n        tile.src = this.getTileUrl(coords)\n      }.bind(this)).catch(function (e) {\n        console.error(e)\n        done(e)\n      })\n    }\n\n    return tile\n  },\n\n  getTileUrl: function (coords) {\n    var quadkey = toQuadKey(coords.x, coords.y, coords.z)\n    var url = L.Util.template(this._url, {\n      quadkey: quadkey,\n      subdomain: this._getSubdomain(coords),\n      culture: this.options.culture\n    })\n    if (typeof this.options.style === 'string') {\n      url += '&st=' + this.options.style\n    }\n    return url\n  },\n\n  // Update the attribution control every time the map is moved\n  onAdd: function (map) {\n    map.on('moveend', this._updateAttribution, this)\n    L.TileLayer.prototype.onAdd.call(this, map)\n    this._attributions.forEach(function (attribution) {\n      map.attributionControl.addAttribution(attribution)\n    })\n  },\n\n  // Clean up events and remove attributions from attribution control\n  onRemove: function (map) {\n    map.off('moveend', this._updateAttribution, this)\n    this._attributions.forEach(function (attribution) {\n      map.attributionControl.removeAttribution(attribution)\n    })\n    L.TileLayer.prototype.onRemove.call(this, map)\n  },\n\n  /**\n   * Get the [Bing Imagery metadata](https://msdn.microsoft.com/en-us/library/ff701712.aspx)\n   * for a specific [`LatLng`](http://leafletjs.com/reference.html#latlng)\n   * and zoom level. If either `latlng` or `zoom` is omitted and the layer is attached\n   * to a map, the map center and current map zoom are used.\n   * @param {L.LatLng} latlng\n   * @param {Number} zoom\n   * @return {Promise} Resolves to the JSON metadata\n   */\n  getMetaData: function (latlng, zoom) {\n    if (!this._map && (!latlng || !zoom)) {\n      return Promise.reject(new Error('If layer is not attached to map, you must provide LatLng and zoom'))\n    }\n    latlng = latlng || this._map.getCenter()\n    zoom = zoom || this._map.getZoom()\n    var PointMetaDataUrl = L.Util.template(L.TileLayer.Bing.POINT_METADATA_URL, {\n      bingMapsKey: this.options.bingMapsKey,\n      imagerySet: this.options.imagerySet,\n      z: zoom,\n      lat: latlng.lat,\n      lng: latlng.lng\n    })\n    return fetchJsonp(PointMetaDataUrl, {jsonpCallback: 'jsonp'})\n      .then(function (response) {\n        return response.json()\n      })\n      .catch(console.error.bind(console))\n  },\n\n  _metaDataOnLoad: function (metaData) {\n    if (metaData.statusCode !== 200) {\n      throw new Error('Bing Imagery Metadata error: \\n' + JSON.stringify(metaData, null, '  '))\n    }\n    var resource = metaData.resourceSets[0].resources[0]\n    this._url = resource.imageUrl\n    this._imageryProviders = resource.imageryProviders || []\n    this.options.subdomains = resource.imageUrlSubdomains\n    this._updateAttribution()\n    return Promise.resolve()\n  },\n\n  /**\n   * Update the attribution control of the map with the provider attributions\n   * within the current map bounds\n   */\n  _updateAttribution: function () {\n    var map = this._map\n    if (!map || !map.attributionControl) return\n    var zoom = map.getZoom()\n    var bbox = toBingBBox(map.getBounds().toBBoxString())\n    this._fetch.then(function () {\n      var newAttributions = this._getAttributions(bbox, zoom)\n      var prevAttributions = this._attributions\n      // Add any new provider attributions in the current area to the attribution control\n      newAttributions.forEach(function (attr) {\n        if (prevAttributions.indexOf(attr) > -1) return\n        map.attributionControl.addAttribution(attr)\n      })\n      // Remove any attributions that are no longer in the current area from the attribution control\n      prevAttributions.filter(function (attr) {\n        if (newAttributions.indexOf(attr) > -1) return\n        map.attributionControl.removeAttribution(attr)\n      })\n      this._attributions = newAttributions\n    }.bind(this))\n  },\n\n  /**\n   * Returns an array of attributions for given bbox and zoom\n   * @private\n   * @param {Array} bbox [west, south, east, north]\n   * @param {Number} zoom\n   * @return {Array} Array of attribution strings for each provider\n   */\n  _getAttributions: function (bbox, zoom) {\n    return this._imageryProviders.reduce(function (attributions, provider) {\n      for (var i = 0; i < provider.coverageAreas.length; i++) {\n        if (bboxIntersect(bbox, provider.coverageAreas[i].bbox) &&\n          zoom >= provider.coverageAreas[i].zoomMin &&\n          zoom <= provider.coverageAreas[i].zoomMax) {\n          attributions.push(provider.attribution)\n          return attributions\n        }\n      }\n      return attributions\n    }, [])\n  }\n})\n\nL.tileLayer.bing = function (options) {\n  return new L.TileLayer.Bing(options)\n}\n\nmodule.exports = L.TileLayer.Bing\n"]}