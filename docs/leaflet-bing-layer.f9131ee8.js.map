{"version":3,"sources":["node_modules/fetch-jsonp/build/fetch-jsonp.js","node_modules/bbox-intersect/index.js","node_modules/leaflet-bing-layer/index.js"],"names":[],"mappings":"ACAA,ACAA;ADCA,ACAA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;ADCA,ADFA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AFDA,AEEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"leaflet-bing-layer.f9131ee8.js","sourceRoot":"..","sourcesContent":["(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['exports', 'module'], factory);\n  } else if (typeof exports !== 'undefined' && typeof module !== 'undefined') {\n    factory(exports, module);\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, mod);\n    global.fetchJsonp = mod.exports;\n  }\n})(this, function (exports, module) {\n  'use strict';\n\n  var defaultOptions = {\n    timeout: 5000,\n    jsonpCallback: 'callback',\n    jsonpCallbackFunction: null\n  };\n\n  function generateCallbackFunction() {\n    return 'jsonp_' + Date.now() + '_' + Math.ceil(Math.random() * 100000);\n  }\n\n  function clearFunction(functionName) {\n    // IE8 throws an exception when you try to delete a property on window\n    // http://stackoverflow.com/a/1824228/751089\n    try {\n      delete window[functionName];\n    } catch (e) {\n      window[functionName] = undefined;\n    }\n  }\n\n  function removeScript(scriptId) {\n    var script = document.getElementById(scriptId);\n    if (script) {\n      document.getElementsByTagName('head')[0].removeChild(script);\n    }\n  }\n\n  function fetchJsonp(_url) {\n    var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    // to avoid param reassign\n    var url = _url;\n    var timeout = options.timeout || defaultOptions.timeout;\n    var jsonpCallback = options.jsonpCallback || defaultOptions.jsonpCallback;\n\n    var timeoutId = undefined;\n\n    return new Promise(function (resolve, reject) {\n      var callbackFunction = options.jsonpCallbackFunction || generateCallbackFunction();\n      var scriptId = jsonpCallback + '_' + callbackFunction;\n\n      window[callbackFunction] = function (response) {\n        resolve({\n          ok: true,\n          // keep consistent with fetch API\n          json: function json() {\n            return Promise.resolve(response);\n          }\n        });\n\n        if (timeoutId) clearTimeout(timeoutId);\n\n        removeScript(scriptId);\n\n        clearFunction(callbackFunction);\n      };\n\n      // Check if the user set their own params, and if not add a ? to start a list of params\n      url += url.indexOf('?') === -1 ? '?' : '&';\n\n      var jsonpScript = document.createElement('script');\n      jsonpScript.setAttribute('src', '' + url + jsonpCallback + '=' + callbackFunction);\n      if (options.charset) {\n        jsonpScript.setAttribute('charset', options.charset);\n      }\n      if (options.nonce) {\n        jsonpScript.setAttribute('nonce', options.nonce);\n      }\n      if (options.referrerPolicy) {\n        jsonpScript.setAttribute('referrerPolicy', options.referrerPolicy);\n      }\n      jsonpScript.id = scriptId;\n      document.getElementsByTagName('head')[0].appendChild(jsonpScript);\n\n      timeoutId = setTimeout(function () {\n        reject(new Error('JSONP request to ' + _url + ' timed out'));\n\n        clearFunction(callbackFunction);\n        removeScript(scriptId);\n        window[callbackFunction] = function () {\n          clearFunction(callbackFunction);\n        };\n      }, timeout);\n\n      // Caught if got 404/500\n      jsonpScript.onerror = function () {\n        reject(new Error('JSONP request to ' + _url + ' failed'));\n\n        clearFunction(callbackFunction);\n        removeScript(scriptId);\n        if (timeoutId) clearTimeout(timeoutId);\n      };\n    });\n  }\n\n  // export as global function\n  /*\n  let local;\n  if (typeof global !== 'undefined') {\n    local = global;\n  } else if (typeof self !== 'undefined') {\n    local = self;\n  } else {\n    try {\n      local = Function('return this')();\n    } catch (e) {\n      throw new Error('polyfill failed because global object is unavailable in this environment');\n    }\n  }\n  local.fetchJsonp = fetchJsonp;\n  */\n\n  module.exports = fetchJsonp;\n});","module.exports = function(bbox1, bbox2){\n  if(!(\n      bbox1[0] > bbox2[2] ||\n      bbox1[2] < bbox2[0] ||\n      bbox1[3] < bbox2[1] ||\n      bbox1[1] > bbox2[3]\n    )){\n      return true;\n  } else {\n    return false;\n  }\n}","var L = require('leaflet')\nvar fetchJsonp = require('fetch-jsonp')\nvar bboxIntersect = require('bbox-intersect')\n\n/**\n * Converts tile xyz coordinates to Quadkey\n * @param {Number} x\n * @param {Number} y\n * @param {Number} z\n * @return {Number} Quadkey\n */\nfunction toQuadKey (x, y, z) {\n  var index = ''\n  for (var i = z; i > 0; i--) {\n    var b = 0\n    var mask = 1 << (i - 1)\n    if ((x & mask) !== 0) b++\n    if ((y & mask) !== 0) b += 2\n    index += b.toString()\n  }\n  return index\n}\n\n/**\n * Converts Leaflet BBoxString to Bing BBox\n * @param {String} bboxString 'southwest_lng,southwest_lat,northeast_lng,northeast_lat'\n * @return {Array} [south_lat, west_lng, north_lat, east_lng]\n */\nfunction toBingBBox (bboxString) {\n  var bbox = bboxString.split(',')\n  return [bbox[1], bbox[0], bbox[3], bbox[2]]\n}\n\nvar VALID_IMAGERY_SETS = [\n  'Aerial',\n  'AerialWithLabels',\n  'AerialWithLabelsOnDemand',\n  'Road',\n  'RoadOnDemand',\n  'CanvasLight',\n  'CanvasDark',\n  'CanvasGray',\n  'OrdnanceSurvey'\n]\n\nvar DYNAMIC_IMAGERY_SETS = [\n  'AerialWithLabelsOnDemand',\n  'RoadOnDemand'\n]\n\n/**\n * Create a new Bing Maps layer.\n * @param {string|object} options Either a [Bing Maps Key](https://msdn.microsoft.com/en-us/library/ff428642.aspx) or an options object\n * @param {string} options.BingMapsKey A valid Bing Maps Key (required)\n * @param {string} [options.imagerySet=Aerial] Type of imagery, see https://msdn.microsoft.com/en-us/library/ff701716.aspx\n * @param {string} [options.culture='en-US'] Language for labels, see https://msdn.microsoft.com/en-us/library/hh441729.aspx\n * @return {L.TileLayer} A Leaflet TileLayer to add to your map\n *\n * Create a basic map\n * @example\n * var map = L.map('map').setView([51.505, -0.09], 13)\n * L.TileLayer.Bing(MyBingMapsKey).addTo(map)\n */\nL.TileLayer.Bing = L.TileLayer.extend({\n  options: {\n    bingMapsKey: null, // Required\n    imagerySet: 'Aerial',\n    culture: 'en-US',\n    minZoom: 1,\n    minNativeZoom: 1,\n    maxNativeZoom: 19\n  },\n\n  statics: {\n    METADATA_URL: 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?key={bingMapsKey}&include=ImageryProviders&uriScheme=https&c={culture}',\n    POINT_METADATA_URL: 'https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}/{lat},{lng}?zl={z}&key={bingMapsKey}&uriScheme=https&c={culture}'\n  },\n\n  initialize: function (options) {\n    if (typeof options === 'string') {\n      options = { bingMapsKey: options }\n    }\n    if (options && options.BingMapsKey) {\n      options.bingMapsKey = options.BingMapsKey\n      console.warn('use options.bingMapsKey instead of options.BingMapsKey')\n    }\n    if (!options || !options.bingMapsKey) {\n      throw new Error('Must supply options.BingMapsKey')\n    }\n    options = L.setOptions(this, options)\n    if (VALID_IMAGERY_SETS.indexOf(options.imagerySet) < 0) {\n      throw new Error(\"'\" + options.imagerySet + \"' is an invalid imagerySet, see https://github.com/digidem/leaflet-bing-layer#parameters\")\n    }\n    if (options && options.style && DYNAMIC_IMAGERY_SETS.indexOf(options.imagerySet) < 0) {\n      console.warn('Dynamic styles will only work with these imagerySet choices: ' + DYNAMIC_IMAGERY_SETS.join(', '))\n    }\n\n    var metaDataUrl = L.Util.template(L.TileLayer.Bing.METADATA_URL, {\n      bingMapsKey: this.options.bingMapsKey,\n      imagerySet: this.options.imagerySet,\n      culture: this.options.culture\n    })\n\n    this._imageryProviders = []\n    this._attributions = []\n\n    // Keep a reference to the promise so we can use it later\n    this._fetch = fetchJsonp(metaDataUrl, {jsonpCallback: 'jsonp'})\n      .then(function (response) {\n        return response.json()\n      })\n      .then(this._metaDataOnLoad.bind(this))\n      .catch(console.error.bind(console))\n\n    // for https://github.com/Leaflet/Leaflet/issues/137\n    if (!L.Browser.android) {\n      this.on('tileunload', this._onTileRemove)\n    }\n  },\n\n  createTile: function (coords, done) {\n    var tile = document.createElement('img')\n\n    L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile))\n    L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile))\n\n    if (this.options.crossOrigin) {\n      tile.crossOrigin = ''\n    }\n\n    /*\n     Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons\n     http://www.w3.org/TR/WCAG20-TECHS/H67\n    */\n    tile.alt = ''\n\n    // Don't create closure if we don't have to\n    if (this._url) {\n      tile.src = this.getTileUrl(coords)\n    } else {\n      this._fetch.then(function () {\n        tile.src = this.getTileUrl(coords)\n      }.bind(this)).catch(function (e) {\n        console.error(e)\n        done(e)\n      })\n    }\n\n    return tile\n  },\n\n  getTileUrl: function (coords) {\n    var quadkey = toQuadKey(coords.x, coords.y, coords.z)\n    var url = L.Util.template(this._url, {\n      quadkey: quadkey,\n      subdomain: this._getSubdomain(coords),\n      culture: this.options.culture\n    })\n    if (typeof this.options.style === 'string') {\n      url += '&st=' + this.options.style\n    }\n    return url\n  },\n\n  // Update the attribution control every time the map is moved\n  onAdd: function (map) {\n    map.on('moveend', this._updateAttribution, this)\n    L.TileLayer.prototype.onAdd.call(this, map)\n    this._attributions.forEach(function (attribution) {\n      map.attributionControl.addAttribution(attribution)\n    })\n  },\n\n  // Clean up events and remove attributions from attribution control\n  onRemove: function (map) {\n    map.off('moveend', this._updateAttribution, this)\n    this._attributions.forEach(function (attribution) {\n      map.attributionControl.removeAttribution(attribution)\n    })\n    L.TileLayer.prototype.onRemove.call(this, map)\n  },\n\n  /**\n   * Get the [Bing Imagery metadata](https://msdn.microsoft.com/en-us/library/ff701712.aspx)\n   * for a specific [`LatLng`](http://leafletjs.com/reference.html#latlng)\n   * and zoom level. If either `latlng` or `zoom` is omitted and the layer is attached\n   * to a map, the map center and current map zoom are used.\n   * @param {L.LatLng} latlng\n   * @param {Number} zoom\n   * @return {Promise} Resolves to the JSON metadata\n   */\n  getMetaData: function (latlng, zoom) {\n    if (!this._map && (!latlng || !zoom)) {\n      return Promise.reject(new Error('If layer is not attached to map, you must provide LatLng and zoom'))\n    }\n    latlng = latlng || this._map.getCenter()\n    zoom = zoom || this._map.getZoom()\n    var PointMetaDataUrl = L.Util.template(L.TileLayer.Bing.POINT_METADATA_URL, {\n      bingMapsKey: this.options.bingMapsKey,\n      imagerySet: this.options.imagerySet,\n      z: zoom,\n      lat: latlng.lat,\n      lng: latlng.lng\n    })\n    return fetchJsonp(PointMetaDataUrl, {jsonpCallback: 'jsonp'})\n      .then(function (response) {\n        return response.json()\n      })\n      .catch(console.error.bind(console))\n  },\n\n  _metaDataOnLoad: function (metaData) {\n    if (metaData.statusCode !== 200) {\n      throw new Error('Bing Imagery Metadata error: \\n' + JSON.stringify(metaData, null, '  '))\n    }\n    var resource = metaData.resourceSets[0].resources[0]\n    this._url = resource.imageUrl\n    this._imageryProviders = resource.imageryProviders || []\n    this.options.subdomains = resource.imageUrlSubdomains\n    this._updateAttribution()\n    return Promise.resolve()\n  },\n\n  /**\n   * Update the attribution control of the map with the provider attributions\n   * within the current map bounds\n   */\n  _updateAttribution: function () {\n    var map = this._map\n    if (!map || !map.attributionControl) return\n    var zoom = map.getZoom()\n    var bbox = toBingBBox(map.getBounds().toBBoxString())\n    this._fetch.then(function () {\n      var newAttributions = this._getAttributions(bbox, zoom)\n      var prevAttributions = this._attributions\n      // Add any new provider attributions in the current area to the attribution control\n      newAttributions.forEach(function (attr) {\n        if (prevAttributions.indexOf(attr) > -1) return\n        map.attributionControl.addAttribution(attr)\n      })\n      // Remove any attributions that are no longer in the current area from the attribution control\n      prevAttributions.filter(function (attr) {\n        if (newAttributions.indexOf(attr) > -1) return\n        map.attributionControl.removeAttribution(attr)\n      })\n      this._attributions = newAttributions\n    }.bind(this))\n  },\n\n  /**\n   * Returns an array of attributions for given bbox and zoom\n   * @private\n   * @param {Array} bbox [west, south, east, north]\n   * @param {Number} zoom\n   * @return {Array} Array of attribution strings for each provider\n   */\n  _getAttributions: function (bbox, zoom) {\n    return this._imageryProviders.reduce(function (attributions, provider) {\n      for (var i = 0; i < provider.coverageAreas.length; i++) {\n        if (bboxIntersect(bbox, provider.coverageAreas[i].bbox) &&\n          zoom >= provider.coverageAreas[i].zoomMin &&\n          zoom <= provider.coverageAreas[i].zoomMax) {\n          attributions.push(provider.attribution)\n          return attributions\n        }\n      }\n      return attributions\n    }, [])\n  }\n})\n\nL.tileLayer.bing = function (options) {\n  return new L.TileLayer.Bing(options)\n}\n\nmodule.exports = L.TileLayer.Bing\n"]}